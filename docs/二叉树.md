## 二叉树层序遍历

### 题单

* [102.二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

* [107.二叉树的层次遍历II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

* [199.二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

* [637.二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

* [429.N叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

* [515.在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

* [116.填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

* [117.填充每个节点的下一个右侧节点指针II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

* [104.二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

* [111.二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)


### 代码模板

  ```java
    public List<List<Integer>> levelOrder(TreeNode root) {
          List<List<Integer>> res = new ArrayList<>();
          if (root == null) {
              return res;
          }
          Queue<TreeNode> queue = new LinkedList<>();
          queue.offer(root);
          while (!queue.isEmpty()) {
              int size = queue.size();
              List<Integer> level = new ArrayList<>();
              for (int i = 0; i < size; i++) {
                  TreeNode node = queue.poll();
                  level.add(node.val);
                  if (node.left != null) {
                      queue.offer(node.left);
                  }
                  if (node.right != null) {
                      queue.offer(node.right);
                  }
              }
              res.add(level);
          }
          return res;
      }
  ```

  