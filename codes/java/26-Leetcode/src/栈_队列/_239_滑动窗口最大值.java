package 栈_队列;

import tools.Asserts;
import tools.Times;

import java.util.*;

public class _239_滑动窗口最大值 {
	/**
	 * 方法一：优先队列
	 * T = O(n * logn), S = O(n)
	 */
	public static int[] maxSlidingWindowPriorityQueue(int[] nums, int k) {
		int n = nums.length;
		PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>() {
			@Override
			public int compare(int[] pair1, int[] pair2) {
				return pair1[0] != pair2[0] ? pair2[0] - pair1[0] : pair2[1] - pair1[1];
			}
		});

		for (int i = 0; i < k; i++) {
			pq.offer(new int[]{nums[i], i});
		}

		int[] res = new int[n - k + 1];
		res[0] = pq.peek()[0];
		for (int i = k; i < n; i++) {
			pq.offer(new int[]{nums[i], i});
			// 这个值在数组 nums 中的位置出现在滑动窗口左边界的左侧
			while (pq.peek()[1] <= i - k) {
				pq.poll();
			}
			res[i - k + 1] = pq.peek()[0];
		}

		return res;
	}

	/**
	 * 使用双端队列实现滑动窗口的最大值计算
	 * 此方法通过维护一个双端队列（Deque）来优化最大值的查找过程双端队列中始终维护着当前窗口内有可能成为最大值的元素
	 * 当窗口滑动时，通过移除队列中不再处于当前窗口内的元素，并确保队列中的元素索引按照其对应的数组元素值递减的顺序排列
	 * 这样，队列的头部始终是当前窗口内的最大值
	 *
	 * @param nums 输入的整数数组
	 * @param k 滑动窗口的大小
	 * @return 每个滑动窗口内的最大值组成的数组
	 */
	public int[] maxSlidingWindow_deque(int[] nums, int k) {
	    // 处理边界情况：如果数组为空或k为0，则返回空数组
	    if(nums.length == 0 || k == 0) return new int[0];

	    // 使用双端队列来存储当前窗口内有可能成为最大值的元素的索引
	    Deque<Integer> deque = new LinkedList<>();
	    // 结果数组，长度为原数组长度减去窗口大小加上1
	    int[] res = new int[nums.length - k + 1];

	    // 遍历数组，i代表当前窗口的左边界，j代表当前窗口的右边界
	    for(int j = 0, i = 1 - k; j < nums.length; i++, j++) {
	        // 删除 deque 中对应的 nums[i-1]
	        if(i > 0 && deque.peekFirst() == nums[i - 1])
	            deque.removeFirst();

	        // 保持 deque 递减
	        while(!deque.isEmpty() && deque.peekLast() < nums[j])
	            deque.removeLast();

	        // 将当前元素添加到deque的末尾
	        deque.addLast(nums[j]);

	        // 记录窗口最大值
	        if(i >= 0)
	            res[i] = deque.peekFirst();
	    }

	    // 返回结果数组
	    return res;
	}

	/**
	 * 使用双端队列实现滑动窗口的最大值计算
	 * 此方法利用双端队列来跟踪窗口中的最大值，从而在O(n)时间内完成计算
	 *
	 * @param nums 输入的整数数组
	 * @param k 窗口的大小
	 * @return 每个窗口中的最大值组成的数组
	 */
	public int[] maxSlidingWindow_deque2(int[] nums, int k) {
	    // 处理边界情况：如果数组为空或k为0，返回空数组
	    if(nums.length == 0 || k == 0) return new int[0];

	    // 使用双端队列来存储当前窗口中可能的最大值
	    Deque<Integer> deque = new LinkedList<>();
	    // 结果数组，长度为原数组长度减去窗口大小加上1
	    int[] res = new int[nums.length - k + 1];

	    // 填充初始窗口，移除所有小于当前值的值，因为它们不可能是最大值
	    for(int i = 0; i < k; i++) {
	        while(!deque.isEmpty() && deque.peekLast() < nums[i])
	            deque.removeLast();
	        deque.addLast(nums[i]);
	    }
	    // 窗口形成后，第一个窗口的最大值在队列的头部
	    res[0] = deque.peekFirst();

	    // 遍历数组，处理形成窗口后的元素
	    for(int i = k; i < nums.length; i++) {
	        // 如果队列头部的元素等于窗口前一个元素，说明它已经不在当前窗口内，需要移除
	        if(deque.peekFirst() == nums[i - k])
	            deque.removeFirst();
	        // 类似于初始窗口的处理，移除所有小于当前元素的元素
	        while(!deque.isEmpty() && deque.peekLast() < nums[i])
	            deque.removeLast();
	        deque.addLast(nums[i]);
	        // 当前窗口的最大值在队列的头部，将其添加到结果数组中
	        res[i - k + 1] = deque.peekFirst();
	    }
	    // 返回结果数组
	    return res;
	}

	/**
	 * 方法二：单调队列
	 * T = O(n), S = O(k)
	 *
	 * 时间复杂度 O(n) ： 其中 n 为数组 nums 长度；线性遍历 nums 占用 O(n) ；每个元素最多仅入队和出队一次，因此单调队列 deque 占用 O(2n) 。
	 * 空间复杂度 O(k) ： 双端队列 deque 中最多同时存储 k 个元素（即窗口大小）。
	 */
	public int[] maxSlidingWindow_deque3(int[] nums, int k) {
	    // 如果数组为空或k为0，返回空数组
	    if(nums.length == 0 || k == 0) {
	        return new int[0];
	    }

	    int n = nums.length;
	    int[] res = new int[n - k + 1];
	    Deque<Integer> deque = new LinkedList<>();

	    // 未形成窗口阶段：初始化单调队列
	    for (int i = 0; i < k; ++i) {
	        // 移除队列中所有小于当前元素的值，保持队列单调递减
	        while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {
	            deque.pollLast();
	        }
	        // 将当前元素索引加入队列
	        deque.offerLast(i);
	    }

	    // 将第一个窗口的最大值加入结果数组
	    res[0] = nums[deque.peekFirst()];

	    // 形成窗口后阶段：更新单调队列并计算每个窗口的最大值
	    for (int i = k; i < n; ++i) {
	        // 同未形成窗口阶段，保持队列单调递减
	        while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {
	            deque.pollLast();
	        }
	        // 将当前元素索引加入队列
	        deque.offerLast(i);
	        // 移除队列中不在当前窗口内的元素的索引
	        while (deque.peekFirst() <= i - k) {
	            deque.pollFirst();
	        }
	        // 将当前窗口的最大值加入结果数组
	        res[i - k + 1] = nums[deque.peekFirst()];
	    }
	    // 返回结果数组
	    return res;
	}

    /**
     * 使用双端队列实现滑动窗口的最大值计算
     * 此方法通过维护一个双端队列来优化最大值的查找过程，确保窗口滑动时能够高效地更新最大值
     *
     * @param nums 输入的整数数组，代表需要计算滑动窗口最大值的序列
     * @param k 滑动窗口的大小，即每个子数组的长度
     * @return 返回一个整数数组，包含每个滑动窗口的最大值
     */
    public int[] maxSlidingWindow_deque4(int[] nums, int k) {
        // 处理边界情况：输入数组为空、长度为0或k小于1时，返回空数组
        if (nums == null || nums.length == 0 || k < 1) return new int[0];
        // 当滑动窗口大小为1时，每个元素自身即为窗口的最大值，直接返回原数组
        if (k == 1) return nums;

        // 初始化结果数组，长度为原数组长度减去k再加1，用于存储每个窗口的最大值
        int[] maxes = new int[nums.length - k + 1];

        // 使用双端队列来维护可能成为窗口最大值的元素的索引
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < nums.length; i++) {
            // 1、只要 nums[队尾] <= nums[i] ，就删除队尾
            // 这一步确保队列中的元素是按大小顺序排列的，队头是最大值
            while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {
                deque.pollLast();
            }

            // 2、将 i 加到队尾
            // 将当前元素的索引加入队列，准备进行后续的比较和窗口最大值的计算
            deque.offerLast(i);

            // 3、检查窗口的索引是否合法
            // 计算当前窗口的起始索引，如果小于0则表示当前窗口尚未形成，跳过当前循环
            int w = i - k + 1;
            if (w < 0) continue;

            // 4、检查队头的合法性
            // 如果队头元素的索引不在当前窗口范围内，则将其移除队头
            if (deque.peekFirst() < w) {
                deque.pollFirst();
            }

            // 5、设置窗口的最大值
            // 此时队头元素即为当前窗口的最大值，将其存入结果数组对应位置
            maxes[w] = nums[deque.peekFirst()];
        }
        // 返回结果数组，包含每个滑动窗口的最大值
        return maxes;
    }

	/**
	 * 会超时
	 * @param nums
	 * @param k
	 * @return
	 */
	public int[] maxSlidingWindow(int[] nums, int k) {
		if (nums == null || nums.length == 0 || k < 1) return new int[0];
		if (k == 1) return nums;
		
		int[] maxes = new int[nums.length - k + 1];
		
		// 当前滑动窗口的最大值索引
		int maxIdx = 0;
		// 求出前 k 个元素的最大值索引
		for (int i = 1; i < k; i++) {
			if (nums[i] > nums[maxIdx]) maxIdx = i;
		}
		
		// li 是滑动窗口的最左边索引
		for (int li = 0; li < maxes.length; li++) {
			// ri 是滑动窗口的最右边索引
			int ri = li + k - 1;
			if (maxIdx < li) { // 最大值的索引不在滑动窗口的合理范围内
				// 求 [li, ri] 范围内最大值的索引
				maxIdx = li;
				for (int i = li + 1; i <= ri; i++) {
					if (nums[i] > nums[maxIdx]) maxIdx = i;
				}
			} else if (nums[ri] >= nums[maxIdx]) {
				maxIdx = ri;
			}
			maxes[li] = nums[maxIdx];
		}
		
		return maxes;
	}

	public static void main(String[] args) {
		_239_滑动窗口最大值 obj = new _239_滑动窗口最大值();
		Asserts.test(Arrays.equals(new int[]{3,3,5,5,6,7}, obj.maxSlidingWindowPriorityQueue(new int[]{1,3,-1,-3,5,3,6,7}, 3)));
		Asserts.test(Arrays.equals(new int[]{3,3,5,5,6,7}, obj.maxSlidingWindow_deque(new int[]{1,3,-1,-3,5,3,6,7}, 3)));
		Asserts.test(Arrays.equals(new int[]{3,3,5,5,6,7}, obj.maxSlidingWindow_deque2(new int[]{1,3,-1,-3,5,3,6,7}, 3)));
		Asserts.test(Arrays.equals(new int[]{3,3,5,5,6,7}, obj.maxSlidingWindow_deque3(new int[]{1,3,-1,-3,5,3,6,7}, 3)));
		Asserts.test(Arrays.equals(new int[]{3,3,5,5,6,7}, obj.maxSlidingWindow_deque4(new int[]{1,3,-1,-3,5,3,6,7}, 3)));
		Asserts.test(Arrays.equals(new int[]{3,3,5,5,6,7}, obj.maxSlidingWindow(new int[]{1,3,-1,-3,5,3,6,7}, 3)));

		int [] nums = {5000,5000,5000,5000,5000,5000,5000,5000,5000,5000,4999,4999,4999,4999,4999,4999,4999,4999,4999,4999,4998,4998,4998,4998,4998,4998,4998,4998,4998,4998,4997,4997,4997,4997,4997,4997,4997,4997,4997,4997,4996,4996,4996,4996,4996,4996,4996,4996,4996,4996,4995,4995,4995,4995,4995,4995,4995,4995,4995,4995,4994,4994,4994,4994,4994,4994,4994,4994,4994,4994,4993,4993,4993,4993,4993,4993,4993,4993,4993,4993,4992,4992,4992,4992,4992,4992,4992,4992,4992,4992,4991,4991,4991,4991,4991,4991,4991,4991,4991,4991,4990,4990,4990,4990,4990,4990,4990,4990,4990,4990,4989,4989,4989,4989,4989,4989,4989,4989,4989,4989,4988,4988,4988,4988,4988,4988,4988,4988,4988,4988,4987,4987,4987,4987,4987,4987,4987,4987,4987,4987,4986,4986,4986,4986,4986,4986,4986,4986,4986,4986,4985,4985,4985,4985,4985,4985,4985,4985,4985,4985,4984,4984,4984,4984,4984,4984,4984,4984,4984,4984,4983,4983,4983,4983,4983,4983,4983,4983,4983,4983,4982,4982,4982,4982,4982,4982,4982,4982,4982,4982,4981,4981,4981,4981,4981,4981,4981,4981,4981,4981,4980,4980,4980,4980,4980,4980,4980,4980,4980,4980,4979,4979,4979,4979,4979,4979,4979,4979,4979,4979,4978,4978,4978,4978,4978,4978,4978,4978,4978,4978,4977,4977,4977,4977,4977,4977,4977,4977,4977,4977,4976,4976,4976,4976,4976,4976,4976,4976,4976,4976,4975,4975,4975,4975,4975,4975,4975,4975,4975,4975,4974,4974,4974,4974,4974,4974,4974,4974,4974,4974,4973,4973,4973,4973,4973,4973,4973,4973,4973,4973,4972,4972,4972,4972,4972,4972,4972,4972,4972,4972,4971,4971,4971,4971,4971,4971,4971,4971,4971,4971,4970,4970,4970,4970,4970,4970,4970,4970,4970,4970,4969,4969,4969,4969,4969,4969,4969,4969,4969,4969,4968,4968,4968,4968,4968,4968,4968,4968,4968,4968,4967,4967,4967,4967,4967,4967,4967,4967,4967,4967,4966,4966,4966,4966,4966,4966,4966,4966,4966,4966,4965,4965,4965,4965,4965,4965,4965,4965,4965,4965,4964,4964,4964,4964,4964,4964,4964,4964,4964,4964,4963,4963,4963,4963,4963,4963,4963,4963,4963,4963,4962,4962,4962,4962,4962,4962,4962,4962,4962,4962,4961,4961,4961,4961,4961,4961,4961,4961,4961,4961,4960,4960,4960,4960,4960,4960,4960,4960,4960,4960,4959,4959,4959,4959,4959,4959,4959,4959,4959,4959,4958,4958,4958,4958,4958,4958,4958,4958,4958,4958,4957,4957,4957,4957,4957,4957,4957,4957,4957,4957,4956,4956,4956,4956,4956,4956,4956,4956,4956,4956,4955,4955,4955,4955,4955,4955,4955,4955,4955,4955,4954,4954,4954,4954,4954,4954,4954,4954,4954,4954,4953,4953,4953,4953,4953,4953,4953,4953,4953,4953,4952,4952,4952,4952,4952,4952,4952,4952,4952,4952,4951,4951,4951,4951,4951,4951,4951,4951,4951,4951,4950,4950,4950,4950,4950,4950,4950,4950,4950,4950,4949,4949,4949,4949,4949,4949,4949,4949,4949,4949,4948,4948,4948,4948,4948,4948,4948,4948,4948,4948,4947,4947,4947,4947,4947,4947,4947,4947,4947,4947,4946,4946,4946,4946,4946,4946,4946,4946,4946,4946,4945,4945,4945,4945,4945,4945,4945,4945,4945,4945,4944,4944,4944,4944,4944,4944,4944,4944,4944,4944,4943,4943,4943,4943,4943,4943,4943,4943,4943,4943,4942,4942,4942,4942,4942,4942,4942,4942,4942,4942,4941,4941,4941,4941,4941,4941,4941,4941,4941,4941,4940,4940,4940,4940,4940,4940,4940,4940,4940,4940,4939,4939,4939,4939,4939,4939,4939,4939,4939,4939,4938,4938,4938,4938,4938,4938,4938,4938,4938,4938,4937,4937,4937,4937,4937,4937,4937,4937,4937,4937,4936,4936,4936,4936,4936,4936,4936,4936,4936,4936,4935,4935,4935,4935,4935,4935,4935,4935,4935,4935,4934,4934,4934,4934,4934,4934,4934,4934,4934,4934,4933,4933,4933,4933,4933,4933,4933,4933,4933,4933,4932,4932,4932,4932,4932,4932,4932,4932,4932,4932,4931,4931,4931,4931,4931,4931,4931,4931,4931,4931,4930,4930,4930,4930,4930,4930,4930,4930,4930,4930,4929,4929,4929,4929,4929,4929,4929,4929,4929,4929,4928,4928,4928,4928,4928,4928,4928,4928,4928,4928,4927,4927,4927,4927,4927,4927,4927,4927,4927,4927,4926,4926,4926,4926,4926,4926,4926,4926,4926,4926,4925,4925,4925,4925,4925,4925,4925,4925,4925,4925,4924,4924,4924,4924,4924,4924,4924,4924,4924,4924,4923,4923,4923,4923,4923,4923,4923,4923,4923,4923,4922,4922,4922,4922,4922,4922,4922,4922,4922,4922,4921,4921,4921,4921,4921,4921,4921,4921,4921,4921,4920,4920,4920,4920,4920,4920,4920,4920,4920,4920,4919,4919,4919,4919,4919,4919,4919,4919,4919,4919,4918,4918,4918,4918,4918,4918,4918,4918,4918,4918,4917,4917,4917,4917,4917,4917,4917,4917,4917,4917,4916,4916,4916,4916,4916,4916,4916,4916,4916,4916,4915,4915,4915,4915,4915,4915,4915,4915,4915,4915,4914,4914,4914,4914,4914,4914,4914,4914,4914,4914,4913,4913,4913,4913,4913,4913,4913,4913,4913,4913,4912,4912,4912,4912,4912,4912,4912,4912,4912,4912,4911,4911,4911,4911,4911,4911,4911,4911,4911,4911,4910,4910,4910,4910,4910,4910,4910,4910,4910,4910,4909,4909,4909,4909,4909,4909,4909,4909,4909,4909,4908,4908,4908,4908,4908,4908,4908,4908,4908,4908,4907,4907,4907,4907,4907,4907,4907,4907,4907,4907,4906,4906,4906,4906,4906,4906,4906,4906,4906,4906,4905,4905,4905,4905,4905,4905,4905,4905,4905,4905,4904,4904,4904,4904,4904,4904,4904,4904,4904,4904,4903,4903,4903,4903,4903,4903,4903,4903,4903,4903,4902,4902,4902,4902,4902,4902,4902,4902,4902,4902,4901,4901,4901,4901,4901,4901,4901,4901,4901,4901,4900,4900,4900,4900,4900,4900,4900,4900,4900,4900,4899,4899,4899,4899,4899,4899,4899,4899,4899,4899,4898,4898,4898,4898,4898,4898,4898,4898,4898,4898,4897,4897,4897,4897,4897,4897,4897,4897,4897,4897,4896,4896,4896,4896,4896,4896,4896,4896,4896,4896,4895,4895,4895,4895,4895,4895,4895,4895,4895,4895,4894,4894,4894,4894,4894,4894,4894,4894,4894,4894,4893,4893,4893,4893,4893,4893,4893,4893,4893,4893,4892,4892,4892,4892,4892,4892,4892,4892,4892,4892,4891,4891,4891,4891,4891,4891,4891,4891,4891,4891,4890,4890,4890,4890,4890,4890,4890,4890,4890,4890,4889,4889,4889,4889,4889,4889,4889,4889,4889,4889,4888,4888,4888,4888,4888,4888,4888,4888,4888,4888,4887,4887,4887,4887,4887,4887,4887,4887,4887,4887,4886,4886,4886,4886,4886,4886,4886,4886,4886,4886,4885,4885,4885,4885,4885,4885,4885,4885,4885,4885,4884,4884,4884,4884,4884,4884,4884,4884,4884,4884,4883,4883,4883,4883,4883,4883,4883,4883,4883,4883,4882,4882,4882,4882,4882,4882,4882,4882,4882,4882,4881,4881,4881,4881,4881,4881,4881,4881,4881,4881,4880,4880,4880,4880,4880,4880,4880,4880,4880,4880,4879,4879,4879,4879,4879,4879,4879,4879,4879,4879,4878,4878,4878,4878,4878,4878,4878,4878,4878,4878,4877,4877,4877,4877,4877,4877,4877,4877,4877,4877,4876,4876,4876,4876,4876,4876,4876,4876,4876,4876,4875,4875,4875,4875,4875,4875,4875,4875,4875,4875,4874,4874,4874,4874,4874,4874,4874,4874,4874,4874,4873,4873,4873,4873,4873,4873,4873,4873,4873,4873,4872,4872,4872,4872,4872,4872,4872,4872,4872,4872,4871,4871,4871,4871,4871,4871,4871,4871,4871,4871,4870,4870,4870,4870,4870,4870,4870,4870,4870,4870,4869,4869,4869,4869,4869,4869,4869,4869,4869,4869,4868,4868,4868,4868,4868,4868,4868,4868,4868,4868,4867,4867,4867,4867,4867,4867,4867,4867,4867,4867,4866,4866,4866,4866,4866,4866,4866,4866,4866,4866,4865,4865,4865,4865,4865,4865,4865,4865,4865,4865,4864,4864,4864,4864,4864,4864,4864,4864,4864,4864,4863,4863,4863,4863,4863,4863,4863,4863,4863,4863,4862,4862,4862,4862,4862,4862,4862,4862,4862,4862,4861,4861,4861,4861,4861,4861,4861,4861,4861,4861,4860,4860,4860,4860,4860,4860,4860,4860,4860,4860,4859,4859,4859,4859,4859,4859,4859,4859,4859,4859,4858,4858,4858,4858,4858,4858,4858,4858,4858,4858,4857,4857,4857,4857,4857,4857,4857,4857,4857,4857,4856,4856,4856,4856,4856,4856,4856,4856,4856,4856,4855,4855,4855,4855,4855,4855,4855,4855,4855,4855,4854,4854,4854,4854,4854,4854,4854,4854,4854,4854,4853,4853,4853,4853,4853,4853,4853,4853,4853,4853,4852,4852,4852,4852,4852,4852,4852,4852,4852,4852,4851,4851,4851,4851,4851,4851,4851,4851,4851,4851,4850,4850,4850,4850,4850,4850,4850,4850,4850,4850,4849,4849,4849,4849,4849,4849,4849,4849,4849,4849,4848,4848,4848,4848,4848,4848,4848,4848,4848,4848,4847,4847,4847,4847,4847,4847,4847,4847,4847,4847,4846,4846,4846,4846,4846,4846,4846,4846,4846,4846,4845,4845,4845,4845,4845,4845,4845,4845,4845,4845,4844,4844,4844,4844,4844,4844,4844,4844,4844,4844,4843,4843,4843,4843,4843,4843,4843,4843,4843,4843,4842,4842,4842,4842,4842,4842,4842,4842,4842,4842,4841,4841,4841,4841,4841,4841,4841,4841,4841,4841,4840,4840,4840,4840,4840,4840,4840,4840,4840,4840,4839,4839,4839,4839,4839,4839,4839,4839,4839,4839,4838,4838,4838,4838,4838,4838,4838,4838,4838,4838,4837,4837,4837,4837,4837,4837,4837,4837,4837,4837,4836,4836,4836,4836,4836,4836,4836,4836,4836,4836,4835,4835,4835,4835,4835,4835,4835,4835,4835,4835,4834,4834,4834,4834,4834,4834,4834,4834,4834,4834,4833,4833};
		Times.test("优先级队列法", () -> {
			System.out.println(obj.maxSlidingWindowPriorityQueue(nums, 7));
		});
		Times.test("单调队列1", () -> {
			System.out.println(obj.maxSlidingWindow_deque(nums, 7));
		});
		Times.test("单调队列2", () -> {
			System.out.println(obj.maxSlidingWindow_deque2(nums, 7));
		});
		Times.test("单调队列3", () -> {
			System.out.println(obj.maxSlidingWindow_deque2(nums, 7));
		});
		Times.test("单调队列4", () -> {
			System.out.println(obj.maxSlidingWindow_deque2(nums, 7));
		});
		Times.test("双指针法", () -> {
			System.out.println(obj.maxSlidingWindow(nums, 7));
		});
	}
}
